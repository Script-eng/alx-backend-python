#!/bin/bash

# ==============================================================================
# kubctl-0x03: A script to perform and monitor a zero-downtime rolling update.
# ==============================================================================

# --- Define colors for better output ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

# --- Configuration ---
DEPLOYMENT_NAME="django-app-blue"
SERVICE_NAME="django-app-service"
APP_LABEL="app=django-app,version=blue"
NEW_IMAGE_TAG="2.0"

echo -e "${GREEN}### Kubernetes Rolling Update Script ###${NC}"

# --- Step 1: Start Continuous Liveness Check ---
echo -e "\n${YELLOW}[1/4] Starting continuous uptime check...${NC}"

# Get the URL for the service from Minikube
APP_URL=$(minikube service ${SERVICE_NAME} --url)
if [ -z "$APP_URL" ]; then
    echo -e "${RED}Error: Could not get service URL. Is the service running?${NC}"
    exit 1
fi
echo "--> App is accessible at: ${APP_URL}"

# Start a background loop to curl the app every half-second
# This loop will run until it's explicitly killed.
(
  while true; do
    # -s: silent, -o /dev/null: discard output, -w: write http_code
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL})
    if [ "$HTTP_STATUS" -ne 200 ]; then
      echo -e "${RED}[$(date +%T)] Downtime detected! HTTP Status: $HTTP_STATUS${NC}"
    else
      # Use printf to avoid newlines messing up the output
      printf "."
    fi
    sleep 0.5
  done
) &
CURL_PID=$!

# Ensure the curl process is killed when the script exits
trap "echo -e '\n\nCleaning up uptime checker...'; kill $CURL_PID" EXIT

echo "--> Uptime checker is running in the background (PID: $CURL_PID)."
echo "--> Dots indicate successful requests. Any error will be printed."


# --- Step 2: Trigger the Rolling Update ---
echo -e "\n\n${YELLOW}[2/4] Applying updated deployment to trigger the rolling update...${NC}"
kubectl apply -f blue_deployment.yaml


# --- Step 3: Monitor the Update Progress ---
echo -e "\n${YELLOW}[3/4] Monitoring the rollout status...${NC}"
# This command will block until the rollout is complete or fails
kubectl rollout status deployment/${DEPLOYMENT_NAME} --timeout=3m

if [ $? -ne 0 ]; then
    echo -e "${RED}Error: Rolling update failed.${NC}"
    # The trap will automatically kill the curl process
    exit 1
fi

echo -e "\n${GREEN}--> Rolling update completed successfully.${NC}"


# --- Step 4: Verify the Final State ---
# The trap will kill the background curl loop now
trap - EXIT # Clear the trap
kill $CURL_PID
echo -e "\n\n${YELLOW}[4/4] Verifying the final state of the deployment...${NC}"

echo -e "\n--> Current pods:"
kubectl get pods -l ${APP_LABEL}

echo -e "\n--> Verifying image version in the deployment..."
# Use jsonpath to extract the image tag from the running deployment spec
CURRENT_IMAGE=$(kubectl get deployment ${DEPLOYMENT_NAME} -o=jsonpath='{.spec.template.spec.containers[0].image}')

if [[ "$CURRENT_IMAGE" == *"$NEW_IMAGE_TAG"* ]]; then
    echo -e "${GREEN}--> Verification successful! Deployment is running image: ${CURRENT_IMAGE}${NC}"
else
    echo -e "${RED}--> Verification failed! Expected image with tag '${NEW_IMAGE_TAG}', but found '${CURRENT_IMAGE}'.${NC}"
fi

echo -e "\n${GREEN}### Script finished. If no 'Downtime detected' message appeared, the update was zero-downtime. ###${NC}"